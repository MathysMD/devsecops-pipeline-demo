rules:
  - id: sql-injection-string-concat
    pattern-either:
      - pattern: |
          $SQL = "..." + $VAR + "..."
          ...
          $CURSOR.execute($SQL)
      - pattern: |
          $SQL = "..." + $VAR
          ...
          $CURSOR.execute($SQL)
      - pattern: |
          $CURSOR.execute("..." + $VAR + "...")
    message: |
      SQL Injection vulnerability detected. User input is concatenated directly into SQL query.

      RISK: High - Allows attackers to execute arbitrary SQL commands

      REMEDIATION:
      - Use parameterized queries with placeholders (?)
      - Example: cursor.execute("SELECT * FROM users WHERE username = ?", (username,))

      REFERENCES:
      - OWASP: https://owasp.org/www-community/attacks/SQL_Injection
      - CWE-89: https://cwe.mitre.org/data/definitions/89.html
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-89: SQL Injection"
      owasp: "A03:2021 - Injection"
      confidence: HIGH

  - id: weak-crypto-md5
    pattern-either:
      - pattern: hashlib.md5(...)
      - pattern: hashlib.new('md5', ...)
    message: |
      Weak cryptographic hash function MD5 detected.

      RISK: High - MD5 is cryptographically broken and unsuitable for password hashing

      REMEDIATION:
      - Use bcrypt, argon2, or PBKDF2 for password hashing
      - Example with bcrypt:
        import bcrypt
        password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())

      REFERENCES:
      - MD5 vulnerabilities: https://www.kb.cert.org/vuls/id/836068
      - CWE-327: https://cwe.mitre.org/data/definitions/327.html
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-327: Use of Broken Cryptographic Algorithm"
      owasp: "A02:2021 - Cryptographic Failures"
      confidence: HIGH

  - id: ssrf-requests-get
    pattern-either:
      - pattern: requests.get($URL)
      - pattern: requests.post($URL)
      - pattern: requests.request(..., $URL, ...)
    pattern-not-inside: |
      if $URL.startswith(...):
        ...
    message: |
      Server-Side Request Forgery (SSRF) vulnerability detected.

      RISK: High - Allows attackers to make requests to internal services

      REMEDIATION:
      - Validate and sanitize URL input
      - Use allowlist of permitted domains
      - Example:
        allowed_domains = ['api.example.com']
        parsed = urlparse(url)
        if parsed.netloc not in allowed_domains:
            raise ValueError("Invalid domain")

      REFERENCES:
      - OWASP SSRF: https://owasp.org/www-community/attacks/Server_Side_Request_Forgery
      - CWE-918: https://cwe.mitre.org/data/definitions/918.html
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-918: Server-Side Request Forgery"
      owasp: "A10:2021 - Server-Side Request Forgery"
      confidence: MEDIUM

  - id: hardcoded-secret
    pattern-either:
      - pattern: $VAR = "AKIA..."
      - pattern: $VAR = "ghp_..."
      - pattern: |
          $VAR = "..."
          ...
      - patterns:
          - pattern-regex: '(password|secret|api_key|token)\s*=\s*["\'][^"\']{8,}["\']'
    message: |
      Hardcoded secret detected in source code.

      RISK: Critical - Exposes sensitive credentials

      REMEDIATION:
      - Use environment variables: os.getenv('API_KEY')
      - Use secret management: AWS Secrets Manager, HashiCorp Vault
      - Never commit secrets to version control

      REFERENCES:
      - CWE-798: https://cwe.mitre.org/data/definitions/798.html
    languages: [python]
    severity: ERROR
    metadata:
      category: security
      cwe: "CWE-798: Use of Hard-coded Credentials"
      owasp: "A07:2021 - Identification and Authentication Failures"
      confidence: HIGH
